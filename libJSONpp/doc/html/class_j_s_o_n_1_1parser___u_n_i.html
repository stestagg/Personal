<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libJSONpp: JSON::parser_UNI Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_j_s_o_n.html">JSON</a>::<a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html">parser_UNI</a>
  </div>
</div>
<div class="contents">
<h1>JSON::parser_UNI Class Reference</h1><!-- doxytag: class="JSON::parser_UNI" -->A builder class for parsing UNICODE files.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;parser_UNI.h&gt;</code>
<p>

<p>
<a href="class_j_s_o_n_1_1parser___u_n_i-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#dfcdd086bb3bd4e33cc47cecf81a0b5d">fail</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Did parsing generate any <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a>? Unfortunately, there is no way to gague the severity of the <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a> yet.  <a href="#dfcdd086bb3bd4e33cc47cecf81a0b5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#d80b5f844a39f9f5089eef22016864e5">errorcount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Property getter for the errorcount.  <a href="#d80b5f844a39f9f5089eef22016864e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#1ddd51557187d28ff80368ea73af0629">geterrors</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#f2a44400f44058711d0248cbcb4ce65e">haveerror</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has error <code>e</code> been raised yet? for the list of <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a>, see: <a class="el" href="parser__errors_8cpp.html">parser_errors.cpp</a>.  <a href="#f2a44400f44058711d0248cbcb4ce65e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="types_8h.html#bc73ed3eebb94ad6e4b3a4f84fc6f882">achar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#bb7790d76cf4b22aec2d82084938887f">geterrorstring</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">translates an error number into its description  <a href="#bb7790d76cf4b22aec2d82084938887f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#a61dbf526f97309fa64a24768ebda12e">reseterrors</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clear the error list.  <a href="#a61dbf526f97309fa64a24768ebda12e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#53ba841592da214c45020de0d2630e1e">parser_UNI</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#8ed369b4220efb0e2054ddc4358a6f65">parser_UNI</a> (const std::wstring s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maps the NULL TERMINATED string <code>s</code> ready for calling <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#4f83edd1a064162513dcafd7d535020c" title="parses a value from the input stream into rv. the input buffer must already have...">parse(JSON::value &amp;)</a>  <a href="#8ed369b4220efb0e2054ddc4358a6f65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#a4c0c5e303cbbf6d6ed4b3e1f4906130">parser_UNI</a> (const wchar_t *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maps the NULL TERMINATED string <code>s</code> ready for calling <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#4f83edd1a064162513dcafd7d535020c" title="parses a value from the input stream into rv. the input buffer must already have...">parse(JSON::value &amp;)</a>  <a href="#a4c0c5e303cbbf6d6ed4b3e1f4906130"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#cd497daed5916d2b562aa6db152ef886">~parser_UNI</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#85b3985e2f5886c5cecfc0c025f63ffd">unmap</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#4f83edd1a064162513dcafd7d535020c">parse</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">parses a <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> from the input stream into <code>rv</code>. the input buffer must already have been mapped.  <a href="#4f83edd1a064162513dcafd7d535020c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#90162b12d037eaa3128112340a5103f5">parse</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv, std::wstring s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">parses the <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> string <code>s</code> into the <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> <code>rv</code>.  <a href="#90162b12d037eaa3128112340a5103f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#0268ab85791b6bd481cc68b1f44a44ca">parse</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv, const wchar_t *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">see <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#90162b12d037eaa3128112340a5103f5" title="parses the JSON string s into the value rv.">parser_UNI::parse(JSON::value&amp;, std::wstring)</a>  <a href="#0268ab85791b6bd481cc68b1f44a44ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#e2bf2247e12a122f5c747999bb554678">parsefile</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv, const wchar_t *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maps the file <code>s</code> into memory, then parses it into <code>rv</code>  <a href="#e2bf2247e12a122f5c747999bb554678"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#f404a5410ff5b68e269f7135c96506ca">parsefile</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv, const char *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maps the file <code>s</code> into memory, then parses it into <code>rv</code>  <a href="#f404a5410ff5b68e269f7135c96506ca"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#fbe40b4d504928a35c0da29935146358">charisWS</a> (wchar_t test)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a wchar_t an ECMAScript whitespace?  <a href="#fbe40b4d504928a35c0da29935146358"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#7738cb2170132c3347b6a6f35dd813c6">charisEOL</a> (wchar_t test)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a wchar_t an ECMAScript end-of-line?  <a href="#7738cb2170132c3347b6a6f35dd813c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#7648ff1721b67cefba03e7a39146894e">parseEscapes</a> (const wchar_t *strstart, const wchar_t *strend, <a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy a string, decoding escaped chars. The string <code>*strstart</code> ... <code>*strend</code>, will be copied into the std::[w]string <code>rv</code>. Escaped chars are decoded as specified in: <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</a> (7.8.4)  <a href="#7648ff1721b67cefba03e7a39146894e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#a4bc1ab3be0a52e4a1ce421ef9b4b64d">adderror</a> (int num)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple wrapper function for adding error information. this may include line/col information at some date?  <a href="#a4bc1ab3be0a52e4a1ce421ef9b4b64d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#06c82dd60f17027a8b1357e386c51ab9">readstring</a> (<a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a string from the input buffer and parses the esape chars. rv is set to the result.  <a href="#06c82dd60f17027a8b1357e386c51ab9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#d432706e9f222f4185f783859e0ee244">readunquotedstring</a> (<a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;rv)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#477027ff93c367afc59a5cbef9ca8c68">readlit</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> Literal from the input buffer and sets <code>rv</code> to it's <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a>.  <a href="#477027ff93c367afc59a5cbef9ca8c68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#b16bddbb20b38ddcb05ba25319fb5b58">readnum</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads an ECMAScript conformant number from the input buffer.  <a href="#b16bddbb20b38ddcb05ba25319fb5b58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#382a6fa4c4a09b857c5084b81616d2ff">readarray</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads an array from the input stream into <code>rv</code>.  <a href="#382a6fa4c4a09b857c5084b81616d2ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#272aa1c9731600ba1ea3190279672d92">readobject</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads an object from the input stream into <code>rv</code>.  <a href="#272aa1c9731600ba1ea3190279672d92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#5eaefcadf77f97237ecc654f41c0215f">skipWS</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function looks for, and skips over any whitespace or comments under the input pointer.  <a href="#5eaefcadf77f97237ecc654f41c0215f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#86c74ac752c6d06010f8131e845ad90e">getvalue</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Works out the type of, and then reads a <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> from the input stream into <code>rv</code>.  <a href="#86c74ac752c6d06010f8131e845ad90e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#734cafa3f57a9b2b5617492a5ecfd5b0">readhexcode</a> (const wchar_t *str, std::wstring &amp;dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to decode an escaped hex code of the form \xFF.  <a href="#734cafa3f57a9b2b5617492a5ecfd5b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#90c849530f4b3c6e796aa2ac66badad4">readhexquad</a> (const wchar_t *str, std::wstring &amp;dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to decode an escaped hex code of the form \uFFFF.  <a href="#90c849530f4b3c6e796aa2ac66badad4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#ac9856a13e9bf66171ace6a78ca1176f">charisNumeric</a> (wchar_t test)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Could the <code>test</code> char be part of a number?  <a href="#ac9856a13e9bf66171ace6a78ca1176f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#229e1f151cb41b52663ba09797dd7796">hextoint</a> (wchar_t hexchar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">converts a hex character into a binary number. Takes a wchar_t in the range: 0-9, a-f, A-F and returns the numberic <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> that it represents.  <a href="#229e1f151cb41b52663ba09797dd7796"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#073e0e7f748439ba6bd62fc98736cd96">errs</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1unibuffer.html">unibuffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#cc42f08ce1c5b4e3185349cdc778134e">bfr</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#db2ee48be3d78c142d073e74f7d1189f">JSON::test</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#84c787e75307e90d55ddae5e7a8c9aa7">JSON::UNI_test</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A builder class for parsing UNICODE files. 
<p>
The in-memory character encoding for strings is determined at compile time. All conversions are handled automatically <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="53ba841592da214c45020de0d2630e1e"></a><!-- doxytag: member="JSON::parser_UNI::parser_UNI" ref="53ba841592da214c45020de0d2630e1e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser_UNI::parser_UNI           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8ed369b4220efb0e2054ddc4358a6f65"></a><!-- doxytag: member="JSON::parser_UNI::parser_UNI" ref="8ed369b4220efb0e2054ddc4358a6f65" args="(const std::wstring s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser_UNI::parser_UNI           </td>
          <td>(</td>
          <td class="paramtype">const std::wstring&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
maps the NULL TERMINATED string <code>s</code> ready for calling <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#4f83edd1a064162513dcafd7d535020c" title="parses a value from the input stream into rv. the input buffer must already have...">parse(JSON::value &amp;)</a> 
<p>

</div>
</div><p>
<a class="anchor" name="a4c0c5e303cbbf6d6ed4b3e1f4906130"></a><!-- doxytag: member="JSON::parser_UNI::parser_UNI" ref="a4c0c5e303cbbf6d6ed4b3e1f4906130" args="(const wchar_t *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser_UNI::parser_UNI           </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
maps the NULL TERMINATED string <code>s</code> ready for calling <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#4f83edd1a064162513dcafd7d535020c" title="parses a value from the input stream into rv. the input buffer must already have...">parse(JSON::value &amp;)</a> 
<p>

</div>
</div><p>
<a class="anchor" name="cd497daed5916d2b562aa6db152ef886"></a><!-- doxytag: member="JSON::parser_UNI::~parser_UNI" ref="cd497daed5916d2b562aa6db152ef886" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser_UNI::~parser_UNI           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="734cafa3f57a9b2b5617492a5ecfd5b0"></a><!-- doxytag: member="JSON::parser_UNI::readhexcode" ref="734cafa3f57a9b2b5617492a5ecfd5b0" args="(const wchar_t *str, std::wstring &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::readhexcode           </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to decode an escaped hex code of the form \xFF. 
<p>
If the decoding fails, eg: \xFG, then the character '?' is appended instead<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>pointer to the string that contains the \xFF.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>reference to a wstring to which the decoded character will be appended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="90c849530f4b3c6e796aa2ac66badad4"></a><!-- doxytag: member="JSON::parser_UNI::readhexquad" ref="90c849530f4b3c6e796aa2ac66badad4" args="(const wchar_t *str, std::wstring &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::readhexquad           </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to decode an escaped hex code of the form \uFFFF. 
<p>
If the decoding fails, eg: \uFGHI, then the character '?' is appended instead<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>pointer to the string that contains the \uFFFF.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>reference to a wstring to which the decoded character will be appended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac9856a13e9bf66171ace6a78ca1176f"></a><!-- doxytag: member="JSON::parser_UNI::charisNumeric" ref="ac9856a13e9bf66171ace6a78ca1176f" args="(wchar_t test)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::charisNumeric           </td>
          <td>(</td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>test</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Could the <code>test</code> char be part of a number? 
<p>
Note: This function checks to see if <code>test</code> is one of: 0123456789-+.eE<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>test</em>&nbsp;</td><td>The character to test </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fbe40b4d504928a35c0da29935146358"></a><!-- doxytag: member="JSON::parser_UNI::charisWS" ref="fbe40b4d504928a35c0da29935146358" args="(wchar_t test)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::charisWS           </td>
          <td>(</td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>test</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is a wchar_t an ECMAScript whitespace? 
<p>
<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</a> (7.2)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>test</em>&nbsp;</td><td>The character to test </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7738cb2170132c3347b6a6f35dd813c6"></a><!-- doxytag: member="JSON::parser_UNI::charisEOL" ref="7738cb2170132c3347b6a6f35dd813c6" args="(wchar_t test)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::charisEOL           </td>
          <td>(</td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>test</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is a wchar_t an ECMAScript end-of-line? 
<p>
<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</a> (7.3)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>test</em>&nbsp;</td><td>The character to test </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7648ff1721b67cefba03e7a39146894e"></a><!-- doxytag: member="JSON::parser_UNI::parseEscapes" ref="7648ff1721b67cefba03e7a39146894e" args="(const wchar_t *strstart, const wchar_t *strend, astr &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_UNI::parseEscapes           </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>strstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>strend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy a string, decoding escaped chars. The string <code>*strstart</code> ... <code>*strend</code>, will be copied into the std::[w]string <code>rv</code>. Escaped chars are decoded as specified in: <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</a> (7.8.4) 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if the caracter is outside these ranges </dd></dl>

</div>
</div><p>
<a class="anchor" name="229e1f151cb41b52663ba09797dd7796"></a><!-- doxytag: member="JSON::parser_UNI::hextoint" ref="229e1f151cb41b52663ba09797dd7796" args="(wchar_t hexchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parser_UNI::hextoint           </td>
          <td>(</td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>hexchar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
converts a hex character into a binary number. Takes a wchar_t in the range: 0-9, a-f, A-F and returns the numberic <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> that it represents. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if the caracter is outside these ranges </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4bc1ab3be0a52e4a1ce421ef9b4b64d"></a><!-- doxytag: member="JSON::parser_UNI::adderror" ref="a4bc1ab3be0a52e4a1ce421ef9b4b64d" args="(int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_UNI::adderror           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple wrapper function for adding error information. this may include line/col information at some date? 
<p>

</div>
</div><p>
<a class="anchor" name="06c82dd60f17027a8b1357e386c51ab9"></a><!-- doxytag: member="JSON::parser_UNI::readstring" ref="06c82dd60f17027a8b1357e386c51ab9" args="(astr &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::readstring           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a string from the input buffer and parses the esape chars. rv is set to the result. 
<p>

</div>
</div><p>
<a class="anchor" name="d432706e9f222f4185f783859e0ee244"></a><!-- doxytag: member="JSON::parser_UNI::readunquotedstring" ref="d432706e9f222f4185f783859e0ee244" args="(astr &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::readunquotedstring           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to guess what the user meant, because unquoted strings are strictly invalid syntax, this is a best-guess scenario.<p>
Embedded escape chars are decoded, see <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#7648ff1721b67cefba03e7a39146894e" title="copy a string, decoding escaped chars. The string *strstart ... *strend, will be...">parser_UNI::parseEscapes</a><p>
will read all input untill a Whitespace or ':' is encoutered. 
</div>
</div><p>
<a class="anchor" name="477027ff93c367afc59a5cbef9ca8c68"></a><!-- doxytag: member="JSON::parser_UNI::readlit" ref="477027ff93c367afc59a5cbef9ca8c68" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::readlit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> Literal from the input buffer and sets <code>rv</code> to it's <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="b16bddbb20b38ddcb05ba25319fb5b58"></a><!-- doxytag: member="JSON::parser_UNI::readnum" ref="b16bddbb20b38ddcb05ba25319fb5b58" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::readnum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads an ECMAScript conformant number from the input buffer. 
<p>

</div>
</div><p>
<a class="anchor" name="382a6fa4c4a09b857c5084b81616d2ff"></a><!-- doxytag: member="JSON::parser_UNI::readarray" ref="382a6fa4c4a09b857c5084b81616d2ff" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::readarray           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads an array from the input stream into <code>rv</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="272aa1c9731600ba1ea3190279672d92"></a><!-- doxytag: member="JSON::parser_UNI::readobject" ref="272aa1c9731600ba1ea3190279672d92" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::readobject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads an object from the input stream into <code>rv</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="5eaefcadf77f97237ecc654f41c0215f"></a><!-- doxytag: member="JSON::parser_UNI::skipWS" ref="5eaefcadf77f97237ecc654f41c0215f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_UNI::skipWS           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function looks for, and skips over any whitespace or comments under the input pointer. 
<p>
After calling this, the input pointer will be on a non-whitespace char OR the end of stream. 
</div>
</div><p>
<a class="anchor" name="86c74ac752c6d06010f8131e845ad90e"></a><!-- doxytag: member="JSON::parser_UNI::getvalue" ref="86c74ac752c6d06010f8131e845ad90e" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UNI::getvalue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Works out the type of, and then reads a <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> from the input stream into <code>rv</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="dfcdd086bb3bd4e33cc47cecf81a0b5d"></a><!-- doxytag: member="JSON::parser_UNI::fail" ref="dfcdd086bb3bd4e33cc47cecf81a0b5d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::fail           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Did parsing generate any <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a>? Unfortunately, there is no way to gague the severity of the <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a> yet. 
<p>

</div>
</div><p>
<a class="anchor" name="d80b5f844a39f9f5089eef22016864e5"></a><!-- doxytag: member="JSON::parser_UNI::errorcount" ref="d80b5f844a39f9f5089eef22016864e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parser_UNI::errorcount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Property getter for the errorcount. 
<p>

</div>
</div><p>
<a class="anchor" name="1ddd51557187d28ff80368ea73af0629"></a><!-- doxytag: member="JSON::parser_UNI::geterrors" ref="1ddd51557187d28ff80368ea73af0629" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; parser_UNI::geterrors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f2a44400f44058711d0248cbcb4ce65e"></a><!-- doxytag: member="JSON::parser_UNI::haveerror" ref="f2a44400f44058711d0248cbcb4ce65e" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UNI::haveerror           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Has error <code>e</code> been raised yet? for the list of <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a>, see: <a class="el" href="parser__errors_8cpp.html">parser_errors.cpp</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="bb7790d76cf4b22aec2d82084938887f"></a><!-- doxytag: member="JSON::parser_UNI::geterrorstring" ref="bb7790d76cf4b22aec2d82084938887f" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#bc73ed3eebb94ad6e4b3a4f84fc6f882">achar</a> * parser_UNI::geterrorstring           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
translates an error number into its description 
<p>

</div>
</div><p>
<a class="anchor" name="a61dbf526f97309fa64a24768ebda12e"></a><!-- doxytag: member="JSON::parser_UNI::reseterrors" ref="a61dbf526f97309fa64a24768ebda12e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_UNI::reseterrors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clear the error list. 
<p>

</div>
</div><p>
<a class="anchor" name="85b3985e2f5886c5cecfc0c025f63ffd"></a><!-- doxytag: member="JSON::parser_UNI::unmap" ref="85b3985e2f5886c5cecfc0c025f63ffd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JSON::parser_UNI::unmap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4f83edd1a064162513dcafd7d535020c"></a><!-- doxytag: member="JSON::parser_UNI::parse" ref="4f83edd1a064162513dcafd7d535020c" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UNI::parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parses a <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> from the input stream into <code>rv</code>. the input buffer must already have been mapped. 
<p>
Remember, a valid <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> object only has one top-level <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a>. 
</div>
</div><p>
<a class="anchor" name="90162b12d037eaa3128112340a5103f5"></a><!-- doxytag: member="JSON::parser_UNI::parse" ref="90162b12d037eaa3128112340a5103f5" args="(JSON::value &amp;rv, std::wstring s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UNI::parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parses the <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> string <code>s</code> into the <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> <code>rv</code>. 
<p>
If the initial string mapping failed, rv is unchanged, but error 10 is added to the parser 
</div>
</div><p>
<a class="anchor" name="0268ab85791b6bd481cc68b1f44a44ca"></a><!-- doxytag: member="JSON::parser_UNI::parse" ref="0268ab85791b6bd481cc68b1f44a44ca" args="(JSON::value &amp;rv, const wchar_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UNI::parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
see <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#90162b12d037eaa3128112340a5103f5" title="parses the JSON string s into the value rv.">parser_UNI::parse(JSON::value&amp;, std::wstring)</a> 
<p>

</div>
</div><p>
<a class="anchor" name="e2bf2247e12a122f5c747999bb554678"></a><!-- doxytag: member="JSON::parser_UNI::parsefile" ref="e2bf2247e12a122f5c747999bb554678" args="(JSON::value &amp;rv, const wchar_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UNI::parsefile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
maps the file <code>s</code> into memory, then parses it into <code>rv</code> 
<p>

</div>
</div><p>
<a class="anchor" name="f404a5410ff5b68e269f7135c96506ca"></a><!-- doxytag: member="JSON::parser_UNI::parsefile" ref="f404a5410ff5b68e269f7135c96506ca" args="(JSON::value &amp;rv, const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UNI::parsefile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
maps the file <code>s</code> into memory, then parses it into <code>rv</code> 
<p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="db2ee48be3d78c142d073e74f7d1189f"></a><!-- doxytag: member="JSON::parser_UNI::JSON::test" ref="db2ee48be3d78c142d073e74f7d1189f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class JSON::test<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="84c787e75307e90d55ddae5e7a8c9aa7"></a><!-- doxytag: member="JSON::parser_UNI::JSON::UNI_test" ref="84c787e75307e90d55ddae5e7a8c9aa7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class JSON::UNI_test<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="073e0e7f748439ba6bd62fc98736cd96"></a><!-- doxytag: member="JSON::parser_UNI::errs" ref="073e0e7f748439ba6bd62fc98736cd96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#073e0e7f748439ba6bd62fc98736cd96">JSON::parser_UNI::errs</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cc42f08ce1c5b4e3185349cdc778134e"></a><!-- doxytag: member="JSON::parser_UNI::bfr" ref="cc42f08ce1c5b4e3185349cdc778134e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1unibuffer.html">unibuffer</a> <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#cc42f08ce1c5b4e3185349cdc778134e">JSON::parser_UNI::bfr</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>k:/Visual Studio 2008/Projects/libJSONpp/libJSONpp/<a class="el" href="parser___u_n_i_8h.html">parser_UNI.h</a><li>k:/Visual Studio 2008/Projects/libJSONpp/libJSONpp/<a class="el" href="parser___u_n_i_8cpp.html">parser_UNI.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 12 11:47:38 2008 for libJSONpp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>

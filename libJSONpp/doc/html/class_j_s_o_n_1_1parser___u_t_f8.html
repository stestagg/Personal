<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libJSONpp: JSON::parser_UTF8 Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_j_s_o_n.html">JSON</a>::<a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html">parser_UTF8</a>
  </div>
</div>
<div class="contents">
<h1>JSON::parser_UTF8 Class Reference</h1><!-- doxytag: class="JSON::parser_UTF8" -->A builder class for parsing UTF-8 files.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;parser_UTF8.h&gt;</code>
<p>

<p>
<a href="class_j_s_o_n_1_1parser___u_t_f8-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#a7fe13e71520efe7478188af6f836d1f">fail</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has error <code>e</code> been raised yet? for the list of <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a>, see: <a class="el" href="parser__errors_8cpp.html">parser_errors.cpp</a>.  <a href="#a7fe13e71520efe7478188af6f836d1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#8c6baca6a0f18163fa3d36e9b39c8003">errorcount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Property getter for the errorcount.  <a href="#8c6baca6a0f18163fa3d36e9b39c8003"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#4e04b3d9a01020fbb6f65d50fe076763">geterrors</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="types_8h.html#bc73ed3eebb94ad6e4b3a4f84fc6f882">achar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#f56b637e6feed65915e10e8e9a9aaf3d">geterrorstring</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">translates an error number into its description  <a href="#f56b637e6feed65915e10e8e9a9aaf3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#5de60ef31696acaa8128341b0a1a21f4">reseterrors</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clear the error list.  <a href="#5de60ef31696acaa8128341b0a1a21f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#e0d86c88983afae5bdfa4558cc0d02af">haveerror</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Did parsing generate any <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a>? Unfortunately, there is no way to gague the severity of the <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a> yet.  <a href="#e0d86c88983afae5bdfa4558cc0d02af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#524ae6d6fb2b696893e487796a6c0f1d">parser_UTF8</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#20d458ae937d09c55948b095d3e228bc">parser_UTF8</a> (const std::string s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maps the NULL TERMINATED string <code>s</code> ready for calling <a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#f26ebd86e49b9e8c5b3d4fba16001679" title="parses a value from the input stream into rv. the input buffer must already have...">parse(JSON::value &amp;)</a>  <a href="#20d458ae937d09c55948b095d3e228bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#7818ee16111f69bbd0e5176e92472898">parser_UTF8</a> (const char *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maps the NULL TERMINATED string <code>s</code> ready for calling <a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#f26ebd86e49b9e8c5b3d4fba16001679" title="parses a value from the input stream into rv. the input buffer must already have...">parse(JSON::value &amp;)</a>  <a href="#7818ee16111f69bbd0e5176e92472898"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#8fb6b4521e944c35c1fb231b3da3dd5a">~parser_UTF8</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#13441f81fcddc3331a99a2c4e8574710">unmap</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#f26ebd86e49b9e8c5b3d4fba16001679">parse</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">parses a <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> from the input stream into <code>rv</code>. the input buffer must already have been mapped.  <a href="#f26ebd86e49b9e8c5b3d4fba16001679"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#078e9097f481a6e2920bdda053b3f618">parse</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv, std::string s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">parses the <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> string <code>s</code> into the <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> <code>rv</code>.  <a href="#078e9097f481a6e2920bdda053b3f618"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#0bf741954ff7e7e5f8dcd4fd27241682">parse</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv, const char *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">see <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#90162b12d037eaa3128112340a5103f5" title="parses the JSON string s into the value rv.">parser_UNI::parse(JSON::value&amp;, std::wstring)</a>  <a href="#0bf741954ff7e7e5f8dcd4fd27241682"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#5aac5bfafdcd0796bb9f2e6e859ca4b7">parsefile</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv, const char *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maps the file <code>s</code> into memory, then parses it into <code>rv</code>  <a href="#5aac5bfafdcd0796bb9f2e6e859ca4b7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#27d9c721c94772dbc41abf6adb0b97c0">parseEscapes</a> (const char *strstart, const char *strend, <a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy a string, decoding escaped chars. The string <code>*strstart</code> ... <code>*strend</code>, will be copied into the std::[w]string <code>rv</code>. Escaped chars are decoded as specified in: <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</a> (7.8.4)  <a href="#27d9c721c94772dbc41abf6adb0b97c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#d1d46b64bbe46ccd4a91cb9b4daa98cf">adderror</a> (int num)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple wrapper function for adding error information. this may include line/col information at some date?  <a href="#d1d46b64bbe46ccd4a91cb9b4daa98cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#8f26f14d15b59838efb1c75380006513">readstring</a> (<a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a string from the input buffer and parses the esape chars. rv is set to the result.  <a href="#8f26f14d15b59838efb1c75380006513"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#111fd36185edc9a552acb41b5e82daee">readunquotedstring</a> (<a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;rv)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#47c6ac30926aa72be75be6f60e9757f3">readlit</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> Literal from the input buffer and sets <code>rv</code> to it's <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a>.  <a href="#47c6ac30926aa72be75be6f60e9757f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#16d5e391f6d4bb04fd4812ebe9a280fe">readnum</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads an ECMAScript conformant number from the input buffer.  <a href="#16d5e391f6d4bb04fd4812ebe9a280fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#7f390bac9b1df96640acfb3ced3f608f">readarray</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads an array from the input stream into <code>rv</code>.  <a href="#7f390bac9b1df96640acfb3ced3f608f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#327b5ededdd7095bc7bfb05d6d99bdf1">readobject</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads an object from the input stream into <code>rv</code>.  <a href="#327b5ededdd7095bc7bfb05d6d99bdf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#b6bf72aed403690c9db7eb159268ad21">skipWS</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function looks for, and skips over any whitespace or comments under the input pointer.  <a href="#b6bf72aed403690c9db7eb159268ad21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#d46ff8757c23da4275dce8db69a135b7">getvalue</a> (<a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;rv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Works out the type of, and then reads a <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> from the input stream into <code>rv</code>.  <a href="#d46ff8757c23da4275dce8db69a135b7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#19d72d4a8ec0b18ed26a728c46310852">isEOL</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#3d7c3afa269d5a0d5ce7850834456ee2">readhexcode</a> (const char *str, std::string &amp;dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to decode an escaped hex code of the form \xFF.  <a href="#3d7c3afa269d5a0d5ce7850834456ee2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#d6b4bbfea526863b47b6bddc7f78a31c">readhexquad</a> (const char *str, std::string &amp;dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to decode an escaped hex code of the form \uFFFF.  <a href="#d6b4bbfea526863b47b6bddc7f78a31c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#4b6b6df8920ae1eb798d2fb3ee58bfd8">charisNumeric</a> (char test)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will test if <code>test</code> COULD be part of a standard number.  <a href="#4b6b6df8920ae1eb798d2fb3ee58bfd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#9ec1e0f0c9040ae2d73d2051d94546e6">charskipWS</a> (const char **test, int len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will increment <code>test</code> IF it is a UTF-8 whitespace char.  <a href="#9ec1e0f0c9040ae2d73d2051d94546e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#5f6e6c4ecce0d9c741265cab0335c2b0">charskipEOL</a> (const char **test, size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will increment <code>test</code> IF it is a UTF-8 eol char.  <a href="#5f6e6c4ecce0d9c741265cab0335c2b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#5daf7deff5ac8c6643c6a948c2557941">hextoint</a> (char hexchar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">converts a hex character into a binary number. Takes a wchar_t in the range: 0-9, a-f, A-F and returns the numberic <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> that it represents.  <a href="#5daf7deff5ac8c6643c6a948c2557941"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#2f6a518bd6ecd49ed7e675b5f78fc877">errs</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_j_s_o_n_1_1utf8buffer.html">utf8buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#b55fb139082b5de4bc93398e752b3cbd">bfr</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#db2ee48be3d78c142d073e74f7d1189f">JSON::test</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#096e54223fc96719019b00ce30327d1a">JSON::UTF_test</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A builder class for parsing UTF-8 files. 
<p>
The in-memory character encoding for strings is determined at compile time. All conversions are handled automatically <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="524ae6d6fb2b696893e487796a6c0f1d"></a><!-- doxytag: member="JSON::parser_UTF8::parser_UTF8" ref="524ae6d6fb2b696893e487796a6c0f1d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser_UTF8::parser_UTF8           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="20d458ae937d09c55948b095d3e228bc"></a><!-- doxytag: member="JSON::parser_UTF8::parser_UTF8" ref="20d458ae937d09c55948b095d3e228bc" args="(const std::string s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser_UTF8::parser_UTF8           </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
maps the NULL TERMINATED string <code>s</code> ready for calling <a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#f26ebd86e49b9e8c5b3d4fba16001679" title="parses a value from the input stream into rv. the input buffer must already have...">parse(JSON::value &amp;)</a> 
<p>

</div>
</div><p>
<a class="anchor" name="7818ee16111f69bbd0e5176e92472898"></a><!-- doxytag: member="JSON::parser_UTF8::parser_UTF8" ref="7818ee16111f69bbd0e5176e92472898" args="(const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser_UTF8::parser_UTF8           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
maps the NULL TERMINATED string <code>s</code> ready for calling <a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#f26ebd86e49b9e8c5b3d4fba16001679" title="parses a value from the input stream into rv. the input buffer must already have...">parse(JSON::value &amp;)</a> 
<p>

</div>
</div><p>
<a class="anchor" name="8fb6b4521e944c35c1fb231b3da3dd5a"></a><!-- doxytag: member="JSON::parser_UTF8::~parser_UTF8" ref="8fb6b4521e944c35c1fb231b3da3dd5a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser_UTF8::~parser_UTF8           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="19d72d4a8ec0b18ed26a728c46310852"></a><!-- doxytag: member="JSON::parser_UTF8::isEOL" ref="19d72d4a8ec0b18ed26a728c46310852" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool JSON::parser_UTF8::isEOL           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3d7c3afa269d5a0d5ce7850834456ee2"></a><!-- doxytag: member="JSON::parser_UTF8::readhexcode" ref="3d7c3afa269d5a0d5ce7850834456ee2" args="(const char *str, std::string &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::readhexcode           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to decode an escaped hex code of the form \xFF. 
<p>
If the decoding fails, eg: \xFG, then the character '?' is appended instead<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>pointer to the string that contains the \xFF.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>reference to a wstring to which the decoded character will be appended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d6b4bbfea526863b47b6bddc7f78a31c"></a><!-- doxytag: member="JSON::parser_UTF8::readhexquad" ref="d6b4bbfea526863b47b6bddc7f78a31c" args="(const char *str, std::string &amp;dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::readhexquad           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to decode an escaped hex code of the form \uFFFF. 
<p>
If the decoding fails, eg: \uFGHI, then the character '?' is appended instead<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>pointer to the string that contains the \uFFFF.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>reference to a wstring to which the decoded character will be appended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4b6b6df8920ae1eb798d2fb3ee58bfd8"></a><!-- doxytag: member="JSON::parser_UTF8::charisNumeric" ref="4b6b6df8920ae1eb798d2fb3ee58bfd8" args="(char test)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::charisNumeric           </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>test</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will test if <code>test</code> COULD be part of a standard number. 
<p>

</div>
</div><p>
<a class="anchor" name="9ec1e0f0c9040ae2d73d2051d94546e6"></a><!-- doxytag: member="JSON::parser_UTF8::charskipWS" ref="9ec1e0f0c9040ae2d73d2051d94546e6" args="(const char **test, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::charskipWS           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will increment <code>test</code> IF it is a UTF-8 whitespace char. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>test</em>&nbsp;</td><td>A pointer to a char array that holds at least one UTF-8 character to test. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the buffer pointed to by <code>test</code> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if whitespace was skipped. false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f6e6c4ecce0d9c741265cab0335c2b0"></a><!-- doxytag: member="JSON::parser_UTF8::charskipEOL" ref="5f6e6c4ecce0d9c741265cab0335c2b0" args="(const char **test, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::charskipEOL           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will increment <code>test</code> IF it is a UTF-8 eol char. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>test</em>&nbsp;</td><td>A pointer to a char array that holds at least one UTF-8 character to test. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the buffer pointed to by <code>test</code> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if end of line was skipped. false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="27d9c721c94772dbc41abf6adb0b97c0"></a><!-- doxytag: member="JSON::parser_UTF8::parseEscapes" ref="27d9c721c94772dbc41abf6adb0b97c0" args="(const char *strstart, const char *strend, astr &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_UTF8::parseEscapes           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>strstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>strend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
copy a string, decoding escaped chars. The string <code>*strstart</code> ... <code>*strend</code>, will be copied into the std::[w]string <code>rv</code>. Escaped chars are decoded as specified in: <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</a> (7.8.4) 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if the caracter is outside these ranges </dd></dl>

</div>
</div><p>
<a class="anchor" name="5daf7deff5ac8c6643c6a948c2557941"></a><!-- doxytag: member="JSON::parser_UTF8::hextoint" ref="5daf7deff5ac8c6643c6a948c2557941" args="(char hexchar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parser_UTF8::hextoint           </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>hexchar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
converts a hex character into a binary number. Takes a wchar_t in the range: 0-9, a-f, A-F and returns the numberic <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> that it represents. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 if the caracter is outside these ranges </dd></dl>

</div>
</div><p>
<a class="anchor" name="d1d46b64bbe46ccd4a91cb9b4daa98cf"></a><!-- doxytag: member="JSON::parser_UTF8::adderror" ref="d1d46b64bbe46ccd4a91cb9b4daa98cf" args="(int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_UTF8::adderror           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple wrapper function for adding error information. this may include line/col information at some date? 
<p>

</div>
</div><p>
<a class="anchor" name="8f26f14d15b59838efb1c75380006513"></a><!-- doxytag: member="JSON::parser_UTF8::readstring" ref="8f26f14d15b59838efb1c75380006513" args="(astr &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::readstring           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a string from the input buffer and parses the esape chars. rv is set to the result. 
<p>

</div>
</div><p>
<a class="anchor" name="111fd36185edc9a552acb41b5e82daee"></a><!-- doxytag: member="JSON::parser_UTF8::readunquotedstring" ref="111fd36185edc9a552acb41b5e82daee" args="(astr &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::readunquotedstring           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#1009581ac1ad90256bcfd618275becaf">astr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to guess what the user meant, because unquoted strings are strictly invalid syntax, this is a best-guess scenario.<p>
Embedded escape chars are decoded, see <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#7648ff1721b67cefba03e7a39146894e" title="copy a string, decoding escaped chars. The string *strstart ... *strend, will be...">parser_UNI::parseEscapes</a><p>
will read all input untill a Whitespace or ':' is encoutered. 
</div>
</div><p>
<a class="anchor" name="47c6ac30926aa72be75be6f60e9757f3"></a><!-- doxytag: member="JSON::parser_UTF8::readlit" ref="47c6ac30926aa72be75be6f60e9757f3" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::readlit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> Literal from the input buffer and sets <code>rv</code> to it's <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="16d5e391f6d4bb04fd4812ebe9a280fe"></a><!-- doxytag: member="JSON::parser_UTF8::readnum" ref="16d5e391f6d4bb04fd4812ebe9a280fe" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::readnum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads an ECMAScript conformant number from the input buffer. 
<p>

</div>
</div><p>
<a class="anchor" name="7f390bac9b1df96640acfb3ced3f608f"></a><!-- doxytag: member="JSON::parser_UTF8::readarray" ref="7f390bac9b1df96640acfb3ced3f608f" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::readarray           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads an array from the input stream into <code>rv</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="327b5ededdd7095bc7bfb05d6d99bdf1"></a><!-- doxytag: member="JSON::parser_UTF8::readobject" ref="327b5ededdd7095bc7bfb05d6d99bdf1" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::readobject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads an object from the input stream into <code>rv</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="b6bf72aed403690c9db7eb159268ad21"></a><!-- doxytag: member="JSON::parser_UTF8::skipWS" ref="b6bf72aed403690c9db7eb159268ad21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_UTF8::skipWS           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function looks for, and skips over any whitespace or comments under the input pointer. 
<p>
After calling this, the input pointer will be on a non-whitespace char OR the end of stream. 
</div>
</div><p>
<a class="anchor" name="d46ff8757c23da4275dce8db69a135b7"></a><!-- doxytag: member="JSON::parser_UTF8::getvalue" ref="d46ff8757c23da4275dce8db69a135b7" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UTF8::getvalue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Works out the type of, and then reads a <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> from the input stream into <code>rv</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="a7fe13e71520efe7478188af6f836d1f"></a><!-- doxytag: member="JSON::parser_UTF8::fail" ref="a7fe13e71520efe7478188af6f836d1f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::fail           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Has error <code>e</code> been raised yet? for the list of <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a>, see: <a class="el" href="parser__errors_8cpp.html">parser_errors.cpp</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="8c6baca6a0f18163fa3d36e9b39c8003"></a><!-- doxytag: member="JSON::parser_UTF8::errorcount" ref="8c6baca6a0f18163fa3d36e9b39c8003" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parser_UTF8::errorcount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Property getter for the errorcount. 
<p>

</div>
</div><p>
<a class="anchor" name="4e04b3d9a01020fbb6f65d50fe076763"></a><!-- doxytag: member="JSON::parser_UTF8::geterrors" ref="4e04b3d9a01020fbb6f65d50fe076763" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; parser_UTF8::geterrors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f56b637e6feed65915e10e8e9a9aaf3d"></a><!-- doxytag: member="JSON::parser_UTF8::geterrorstring" ref="f56b637e6feed65915e10e8e9a9aaf3d" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#bc73ed3eebb94ad6e4b3a4f84fc6f882">achar</a> * parser_UTF8::geterrorstring           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
translates an error number into its description 
<p>

</div>
</div><p>
<a class="anchor" name="5de60ef31696acaa8128341b0a1a21f4"></a><!-- doxytag: member="JSON::parser_UTF8::reseterrors" ref="5de60ef31696acaa8128341b0a1a21f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_UTF8::reseterrors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clear the error list. 
<p>

</div>
</div><p>
<a class="anchor" name="e0d86c88983afae5bdfa4558cc0d02af"></a><!-- doxytag: member="JSON::parser_UTF8::haveerror" ref="e0d86c88983afae5bdfa4558cc0d02af" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parser_UTF8::haveerror           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Did parsing generate any <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a>? Unfortunately, there is no way to gague the severity of the <a class="el" href="namespace_j_s_o_n_1_1errors.html">errors</a> yet. 
<p>

</div>
</div><p>
<a class="anchor" name="13441f81fcddc3331a99a2c4e8574710"></a><!-- doxytag: member="JSON::parser_UTF8::unmap" ref="13441f81fcddc3331a99a2c4e8574710" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JSON::parser_UTF8::unmap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f26ebd86e49b9e8c5b3d4fba16001679"></a><!-- doxytag: member="JSON::parser_UTF8::parse" ref="f26ebd86e49b9e8c5b3d4fba16001679" args="(JSON::value &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UTF8::parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parses a <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> from the input stream into <code>rv</code>. the input buffer must already have been mapped. 
<p>
Remember, a valid <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> object only has one top-level <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a>. 
</div>
</div><p>
<a class="anchor" name="078e9097f481a6e2920bdda053b3f618"></a><!-- doxytag: member="JSON::parser_UTF8::parse" ref="078e9097f481a6e2920bdda053b3f618" args="(JSON::value &amp;rv, std::string s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UTF8::parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parses the <a class="el" href="namespace_j_s_o_n.html" title="The JSON namespace should hold all public classes/functions/enums/structs of the...">JSON</a> string <code>s</code> into the <a class="el" href="class_j_s_o_n_1_1value.html" title="This class represents any JSON value. A value can have any of the basic JSON datatypes...">value</a> <code>rv</code>. 
<p>
If the initial string mapping failed, rv is unchanged, but error 10 is added to the parser 
</div>
</div><p>
<a class="anchor" name="0bf741954ff7e7e5f8dcd4fd27241682"></a><!-- doxytag: member="JSON::parser_UTF8::parse" ref="0bf741954ff7e7e5f8dcd4fd27241682" args="(JSON::value &amp;rv, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UTF8::parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
see <a class="el" href="class_j_s_o_n_1_1parser___u_n_i.html#90162b12d037eaa3128112340a5103f5" title="parses the JSON string s into the value rv.">parser_UNI::parse(JSON::value&amp;, std::wstring)</a> 
<p>

</div>
</div><p>
<a class="anchor" name="5aac5bfafdcd0796bb9f2e6e859ca4b7"></a><!-- doxytag: member="JSON::parser_UTF8::parsefile" ref="5aac5bfafdcd0796bb9f2e6e859ca4b7" args="(JSON::value &amp;rv, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp; parser_UTF8::parsefile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_s_o_n_1_1value.html">JSON::value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
maps the file <code>s</code> into memory, then parses it into <code>rv</code> 
<p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="db2ee48be3d78c142d073e74f7d1189f"></a><!-- doxytag: member="JSON::parser_UTF8::JSON::test" ref="db2ee48be3d78c142d073e74f7d1189f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class JSON::test<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="096e54223fc96719019b00ce30327d1a"></a><!-- doxytag: member="JSON::parser_UTF8::JSON::UTF_test" ref="096e54223fc96719019b00ce30327d1a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class JSON::UTF_test<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="2f6a518bd6ecd49ed7e675b5f78fc877"></a><!-- doxytag: member="JSON::parser_UTF8::errs" ref="2f6a518bd6ecd49ed7e675b5f78fc877" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#2f6a518bd6ecd49ed7e675b5f78fc877">JSON::parser_UTF8::errs</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b55fb139082b5de4bc93398e752b3cbd"></a><!-- doxytag: member="JSON::parser_UTF8::bfr" ref="b55fb139082b5de4bc93398e752b3cbd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_j_s_o_n_1_1utf8buffer.html">utf8buffer</a> <a class="el" href="class_j_s_o_n_1_1parser___u_t_f8.html#b55fb139082b5de4bc93398e752b3cbd">JSON::parser_UTF8::bfr</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>k:/Visual Studio 2008/Projects/libJSONpp/libJSONpp/<a class="el" href="parser___u_t_f8_8h.html">parser_UTF8.h</a><li>k:/Visual Studio 2008/Projects/libJSONpp/libJSONpp/<a class="el" href="parser___u_t_f8_8cpp.html">parser_UTF8.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Apr 12 11:47:38 2008 for libJSONpp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
